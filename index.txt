
test100.cpp
/*******************************************************************
 * Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.
 *
 * Note:
 * You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.
 * ******************************************************************/
 
test101.cpp
/**********************************************************************
 * Given a binary tree, determine if it is a valid binary search tree (BST).
 *
 * Assume a BST is defined as follows:
 *
 * The left subtree of a node contains only nodes with keys less than the node's key.
 * The right subtree of a node contains only nodes with keys greater than the node's key.
 * Both the left and right subtrees must also be binary search trees.''
 * *****************************************************************/
 
test102.cpp
/**********************************************************************
 * Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
 *
 * For example,
 * "A man, a plan, a canal: Panama" is a palindrome.
 * "race a car" is not a palindrome.
 *
 * Note:
 * Have you consider that the string might be empty? This is a good question to ask during an interview.
 *
 * For the purpose of this problem, we define empty string as valid palindrome.""""
 * ********************************************************************/
 
test103.cpp
/**********************************************************************
 * 两个数相乘的高精度算法，
 * *******************************************************************/
 
test104.cpp
/*********************************************************************
 * Given two words (beginWord and endWord), and a dictionary, find the length of shortest transformation sequence from beginWord to endWord, such that:
 *
 * Only one letter can be changed at a time
 * Each intermediate word must exist in the dictionary
 * For example,
 *
 * Given:
 * start = "hit"
 * end = "cog"
 * dict = ["hot","dot","dog","lot","log"]
 * As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
 * return its length 5.
 *
 * Note:
 * Return 0 if there is no such transformation sequence.
 * All words have the same length.
 * All words contain only lowercase alphabetic characters.]
 * ******************************************************************/
 
test105.cpp
/************************************************************************
 * Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that:
 *
 * Only one letter can be changed at a time
 * Each intermediate word must exist in the dictionary
 * For example,
 *
 * Given:
 * start = "hit"
 * end = "cog"
 * dict = ["hot","dot","dog","lot","log"]
 * Return
 *   [
 *       ["hit","hot","dot","dog","cog"],
 *           ["hit","hot","lot","log","cog"]
 *             ]
 *             Note:
 *             All words have the same length.
 *             All words contain only lowercase alphabetic characters.
 *             ]
 *      ]
 *  ]
 * *******************************************************************/
 
test106.c
/**************************************************************
 * memcpy()
 * *************************************************************/
 
test107.cpp
/*******************************************************************
 * You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
 *
 * Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
 * Output: 7 -> 0 -> 8
 * *****************************************************************/
 
test108.cpp
/*********************************************************************
 * Given an integer, convert it to a roman numeral.
 *
 * Input is guaranteed to be within the range from 1 to 3999.
 * ******************************************************************/
 
test109.cpp
/*************************************************************************
 * Given a roman numeral, convert it to an integer.
 *
 * Input is guaranteed to be within the range from 1 to 3999.
 * **********************************************************************/
 
test10.c
/*******************************************************************
 * 把n个色子扔在地上，所有色子朝上一面的点数之和为s。
 * 输入n，打印出s的所有可能值出现的概率。
 * ****************************************************************/
 
test10.cpp
/*******************************************************************
 * 把n个色子扔在地上，所有色子朝上一面的点数之和为s。
 * 输入n，打印出s的所有可能值出现的概率。
 * ****************************************************************/
 
test110.cpp

/************************************************************************
 * Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
 *
 * For example, given n = 3, a solution set is:
 *
 * "((()))", "(()())", "(())()", "()(())", "()()()"
 * ********************************************************************/
 
test111.cpp
/***********************************************************************
 * Given a linked list, swap every two adjacent nodes and return its head.
 *
 * For example,
 * Given 1->2->3->4, you should return the list as 2->1->4->3.
 *
 * Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.
 * *******************************************************************/
 
test112.cpp
/*******************************************************************
 * Given an array and a value, remove all instances of that value in place and return the new length.
 *
 * The order of elements can be changed. It doesn't matter what you leave beyond the new length.'
 * *****************************************************************/
 
test113.cpp
/**********************************************************************
 * Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
 *
 * If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).
 *
 * The replacement must be in-place, do not allocate extra memory.
 *
 * Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.
 * 1,2,3 → 1,3,2
 * 3,2,1 → 1,2,3
 * 1,1,5 → 1,5,1
 * ********************************************************************/
 
test114.cpp
/*****************************************************************
 * Given an array of strings, return all groups of strings that are anagrams.
 *
 * Note: All inputs will be in lower-case.
 * *************************************************************/
 
test115.cpp
/**********************************************************************
 * Given two binary strings, return their sum (also a binary string).
 *
 * For example,
 * a = "11"
 * b = "1"
 * Return "100".
 * ******************************************************************/
 
test116.cpp
/******************************************************************
 * Implement int sqrt(int x).
 *
 * Compute and return the square root of x.
 * *****************************************************************/
 
test117.cpp
/************************************************************************
 * 给定一个排好升序的数组A[1]、A[2]、……、A[n]，其元素的值都两两不相等。
 * 请设计一高效的算法找出中间所有A[i] = i的下标。
 * *******************************************************************/
 
test118.cpp
/****************************************************************
 * Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.
 *
 * Ensure that numbers within the set are sorted in ascending order.
 *
 *
 * Example 1:
 *
 * Input: k = 3, n = 7
 *
 * Output:
 *
 * [[1,2,4]]
 *
 * Example 2:
 *
 * Input: k = 3, n = 9
 *
 * Output:
 *
 * [[1,2,6], [1,3,5], [2,3,4]]
 * Credits:
 * Special thanks to @mithmatt for adding this problem and creating all test cases.
 * ***************************************************************/
 
test119.cpp
/******************************************************************
 * Given a 2D board and a word, find if the word exists in the grid.
 *
 * The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
 *
 * For example,
 * Given board =
 *
 * [
 *   ["ABCE"],
 *   ["SFCS"],
 *   ["ADEE"]
 * ]
 *       word = "ABCCED", -> returns true,
 *       word = "SEE", -> returns true,
 *       word = "ABCB", -> returns false.
 * **************************************************************/
 
test11.cpp
/****************************************************************
 * 从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的
 * A为1，J为11，Q为12，K为13，而大小王看作任意数字。
 * *************************************************************/
 
test120.cpp
/*******************************************************************
 * 实现8大排序算法，
 * 冒泡排序、插入排序、希尔排序、选择排序、归并排序、快速排序、基数排序、堆排序
 * 时间复杂度分析。
 * ****************************************************************/
 
test121.cpp
/************************************************************
 * 实现下列程序
 * *
 
test122.cpp
/*****************************************************************
 * 巧排数字，将1,2,...,19,20这20个数字排成一排，使得相邻的两个数字之和为一个素数，且
 * 首尾两数字之和也为一个素数。编程打印出所有的排法。
 * *************************************************************/
 
test123.cpp
/************************************************************************
 * 打印一个N*N的方阵，N为每边字符的个数（ 3〈N〈20 ），要求最外层为"X"，第二层为"Y"，从第三层起每层依次打印数字0，1，2，3，...
 * 例子：当N =5，打印出下面的图形：
 *  X X X X X
 *  X Y Y Y X
 *  X Y 0 Y X
 *  X Y Y Y X
 *  X X X X X 
 * *******************************************************************/
 
test124.cpp
/***************************************************************
 * Strlen()的c语言实现，不能使用任何变量
 * *************************************************************/
 
test125.cpp
/**********************************************************************
 * 已知strcpy的函数原型：char *strcpy(char *strDest, const char *strSrc)
 * strDest 是目的字符串，strSrc 是源字符串。
 * 不调用C++/C 的字符串库函数，请编写函数 strcpy。
 * *******************************************************************/
 
test126.cpp
/*********************************************************************
 * Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).
 *
 * For example:
 * Given binary tree {3,9,20,#,#,15,7},
 *     3
 *    / \
 *    9  20
 *      /  \
 *      15   7
 * return its level order traversal as:
 *  [
 *   [3],
 *   [9,20],
 *   [15,7]
 *  ]
 * confused what "{1,#,2,3}" means? > read more on how binary tree is serialized on OJ.
 *
 *
 *  OJ's Binary Tree Serialization:
 *  The serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below.
 *
 *  Here's an example:
 *       1
 *      / \
 *     2   3
 *         /
 *        4
 *         \
 *          5
 *  The above binary tree is serialized as "{1,2,3,#,#,4,#,#,5}".
 * ******************************************************************/
 
test127.cpp
/*********************************************************************
 * Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.
 *
 * An example is the root-to-leaf path 1->2->3 which represents the number 123.
 *
 * Find the total sum of all root-to-leaf numbers.
 *
 * For example,
 *
 *     1
 *    / \
 *   2   3
 * The root-to-leaf path 1->2 represents the number 12.
 * The root-to-leaf path 1->3 represents the number 13.
 *
 * Return the sum = 12 + 13 = 25.
 * ******************************************************************/
 
test128.cpp
/*********************************************************************
 * 洗牌法
 * 将洗牌看作全排列，随机取出一种排列方式，
 * 概率问题 将1～54看作54张牌，
 * rand()%54与第一张牌交换，rand()%53+i与第二张牌交换
 * ******************************************************************/
 
test129.cpp
/**********************************************************************
 * 判断一包含n个整数a[]中是否存在i、j、k
 * 满足a[i] + a[j] = a[k]的时间复杂度为O(n^2)
 * *******************************************************************/
 
test12.c
/**********************************************************************
 * 0，1，...，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里
 * 删除第m个数字。求出这个圆圈剩下最后一个数字。
 * ********************************************************************/
 
test12.cpp
/**********************************************************************
 * 0，1，...，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里
 * 删除第m个数字。求出这个圆圈剩下最后一个数字。
 * ********************************************************************/
 
test130.cpp
/*******************************************************************
 * 在实际项目中，我们可能会用字符串来表示无法用普通数据类型（int/float）来存储的数值，在这里我们把它们定义为大数。请实现两个字符串表示的大数相减的程序。例如：“1234567890123.1”-“123456789.1”=“1234444433334” 
 * 要求： 
 * 1、可以使用任何语言。 
 * 2、不可以使用大数类。 
 * 输出的结果也是用字符串表示的大数
 * ***************************************************************/
 
test131.cpp
/******************************************************************
 * 网易的笔试题一道:
 *  
 *  如图：
 *   7	8	9	10
 *   6	1	2	11
 *	 5	4	3	12
 *	 16	15	14	13
 *
 *    设“1”的坐标为（0，0） “7”的坐标为（－1，－1） 
 *    编写一个小程序，使程序做到输入坐标（X,Y）之后显示出相应的数字。
 * ***************************************************************/
 
test132.c
/******************************************************************
 * 动态数组 
 * 功能：
 *		 Ret darray_insert(DArray *thiz, size_t index, void* data);
 *		 Ret darray_prepend(DArray *thiz, void *data);
 *		 Ret darray_append(DArray *thiz, void *data);
 *		 Ret darray_delete(DArray *thiz, size_t index);
 *		 Ret darray_get_by_index(DArray *thiz, size_t index, void **data);
 *		 Ret darray_set_by_index(DArray *thiz, size_t index, void *data);
 *		 Ret darray_find(DArray *thiz, DataCompareFunc cmp, void* ctx);
 *		 Ret darray_foreach(DArray *thiz, DataVisitFunc visit, void *ctx);
 *		 size_t darray_length(DArray *thiz);
 *		 void darray_delete(DArray *thiz);
 * ***************************************************************/
 
test133.cpp
/****************************************************
 * 通过前序中序建立二叉树
 * **************************************************/
 
test134.cpp
/********************************************************************
 * 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，
 * 每一次只能向左，右，上，下四个方向移动一格，
 * 但是不能进入行坐标和列坐标的数位之和大于k的格子。 
 * 例如，当k为18时，机器人能够进入方格（35,37），
 * 因为3+5+3+7 = 18。但是，它不能进入方格（35,38），
 * 因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？
 * *****************************************************************/
 
test135.cpp
/********************************************************************
 * 设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。
 * 路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，
 * 向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，
 * 则该路径不能再进入该格子。 
 * 例如 a b c e s f c s a d e e 矩阵中包含一条字符串"bccced"的路径，
 * 但是矩阵中不包含"abcb"路径，
 * 因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，
 * 路径不能再次进入该格子。""""
 * ******************************************************************/
 
test136.cpp
/********************************************************************
 * 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。
 * 例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，
 * 那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 
 * 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： 
 * {[2,3,4],2,6,2,5,1}， 
 * {2,[3,4,2],6,2,5,1}， 
 * {2,3,[4,2,6],2,5,1}， 
 * {2,3,4,[2,6,2],5,1}， 
 * {2,3,4,2,[6,2,5],1}， 
 * {2,3,4,2,6,[2,5,1]}。
 * *****************************************************************/
 
test137.cpp
/************************************************************************
 * 如何得到一个数据流中的中位数？
 * 如果从数据流中读出奇数个数值，
 * 那么中位数就是所有数值排序之后位于中间的数值。
 * 如果从数据流中读出偶数个数值，
 * 那么中位数就是所有数值排序之后中间两个数的平均值。
 * *********************************************************************/
 
test138.cpp
/**********************************************************************
 * 给定一颗二叉搜索树，请找出其中的第k大的结点。
 * 例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，
 * 按结点数值大小顺序第三个结点的值为4。
 * ********************************************************************/
 
test139.cpp
/*****************************************************************
 * 请实现两个函数，分别用来序列化和反序列化二叉树
 *
 * **************************************************************/
 
test13.cpp
/*****************************************************************
 * 求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、
 * case等关键字及条件判断语句（A？B：C）。
 * **************************************************************/
 
test140.cpp
/******************************************************************
 * 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。
 * ***************************************************************/
 
test141.cpp
/******************************************************************
 * 请实现一个函数按照之字形打印二叉树，
 * 即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，
 * 第三行按照从左到右的顺序打印，其他行以此类推。
 * ***************************************************************/
 
test142.cpp
/******************************************************************
 * 请实现一个函数，用来判断一颗二叉树是不是对称的。
 * 注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的
 * ***************************************************************/
 
test143.cpp
/******************************************************************
 * 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点
 * 并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
 * ***************************************************************/
 
test144.cpp
/******************************************************************
 * 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
 * ***************************************************************/
 
test145.cpp
/******************************************************************
 * 一个链表中包含环，请找出该链表的环的入口结点。
 * ***************************************************************/
 
test146.cpp
/******************************************************************
 * 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。"""""""
 * ***************************************************************/
 
test147.cpp
/******************************************************************
 * 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。
 * ***************************************************************/
 
test148.cpp
/******************************************************************
 *请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配
 * ***************************************************************/
 
test149.cpp
/******************************************************************
 * 给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法
 * ***************************************************************/
 
test14.c
/*****************************************************************
 * 写一个函数， 求两个整数之和，要求在函数体内不得使用
 * +、-、*、/四则运算符号。
 * ***************************************************************/
 
test150.cpp
/******************************************************************
 * 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。
 * ***************************************************************/
 
test151.cpp
/******************************************************************
 * 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。
 * ***************************************************************/
 
test152.cpp
/******************************************************************
 * 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。
 * ***************************************************************/
 
test153.cpp
/******************************************************************
 * 求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
 * ***************************************************************/
 
test154.cpp
/******************************************************************
 * 每年六一儿童节,NowCoder都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为NowCoder的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为1的小朋友开始报数。每次喊到m的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续1...m报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到NowCoder名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？
 * ***************************************************************/
 
test155.cpp
/******************************************************************
 * LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。
 * ***************************************************************/
 
test156.cpp
/******************************************************************
 * JOBDU最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？
 * ***************************************************************/
 
test157.cpp
/******************************************************************
 * 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！
 * ***************************************************************/
 
test158.cpp
/******************************************************************
 * 输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。
 * ***************************************************************/
 
test159.cpp
/******************************************************************
 * 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!
 * ***************************************************************/
 
test15.c
/*********************************************************
 * 编写StrToInt函数，实现字符串到正数数字的转换。
 * *******************************************************/
 
test160.cpp
/******************************************************************
 * 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
 * ***************************************************************/
 
test161.cpp
/******************************************************************
 * 输入一棵二叉树，判断该二叉树是否是平衡二叉树。
 * ***************************************************************/
 
test162.cpp
/******************************************************************
 * 输入两个链表，找出它们的第一个公共结点。
 * ***************************************************************/
 
test16.c
/***************************************************
 * Remove Duplicates from Sorted Array return the new length
 * do not allocate new space
 * input A=[1,1,3] Output A=[1,3] and length = 2;
 * ************************************************/
 
test16.cpp
/***************************************************
 * Remove Duplicates from Sorted Array return the new length
 * do not allocate new space
 * input A=[1,1,3] Output A=[1,3] and length = 2;
 * ************************************************/
 
test17.c
/*********************************************************
 *	Remove Duplicates from sorted Array 2
 *	Input A={1,1,1,2,2,3} Output A={1,1,2,2,3} and length = 5
 * ******************************************************/
 
test18.c
/************************************************************
 * Search in Rotate Sorted Array
 * if found return its index, else return -1
 * i.e. input 4 5 6 7 0 1 2
 * *********************************************************/
 
test19.c
/***************************************************************
 * The Kth Number of Two Sorted Arrys
 * ***********************************************************/
 
test1.c
/******************************************************
 * 统计数字在排序数组中出现的次数。
 * 如输入排序数组{1,2,3,3,3,3,4,5} 和数字3
 * 输出 4
 * ****************************************************/
 
test1.cpp
/******************************************************
 * 统计数字在排序数组中出现的次数。
 * 如输入排序数组{1,2,3,3,3,3,4,5} 和数字3
 * 输出 4
 * ****************************************************/
 
test20.cpp
/**************************************************************
 * 输入10个数字，按各个位的和从小到大排序
 * 如输入 11 3 2 4 5 9 8 7 10 6
 * 输出 10 2 11 3 4 5 6 7 8 9
 * ***********************************************************/
 
test21.cpp
/***********************************************************************
 * 操作系统任务调度问题。操作系统任务分为系统任务和用户任务两种。其中，
 * 系统任务的优先级 < 50，用户任务的优先级 >= 50且 <= 255。优先级大于255的为非法任务，应予以剔除。
 * 现有一任务队列task[]，长度为n，task中的元素值表示任务的优先级，数值越小，优先级越高。 
 * 函数scheduler实现如下功能：
 * 将task[] 中的任务按照系统任务、用户任务依次存放到 system_task[] 数组和 user_task[] 数组中 
 * （数组中元素的值是任务在task[] 数组中的下标），并且优先级高的任务排在前面，数组元素为-1表示结束。
 * 例如：
 * task[] = {0, 30, 155, 1, 80, 300, 170, 40, 99}    
 * system_task[] = {0, 3, 1, 7, -1}    
 * user_task[]  =  {4, 8, 2, 6, -1}
 * 接口函数：
 * void scheduler(int task[], int n, int system_task[], int user_task[])
 * ********************************************************************/
 
test22.c
/*************************************************************
 * 输入一组身高在170到190之间（5个身高）比较身高，选出身高差最小的两个身高；若身高差相同，选平均身高高的那两个身高；从小到大输出；
 * 如：输入 170 181 173 186 190   输出 170 173
 * *********************************************************/
 
test23.c
/*************************************************************
 * 输入整型数组求数组的最小数和最大数之和，例
 * 如输入1,2,3,4则输出为5，当输入只有一个数的时候，则最小数和最大数都是该数，
 * 例如只输入1，则输出为2；数组的长度不超过50。
 * **********************************************************/
 
test24.c
/******************************************************************8
 * 输入一串字符，只包含“0-10”和“，”找出其中最小的数字和最大的数字
 * （可能不止一个），输出最后剩余数字个数。
 * ***************************************************************/
 
test25.c
/***************************************************************8
 * 一组人（7个），围成一圈，从某人开始数到第3个的人出列，
 * 再接着从下一个人开始数，依次输出出列的人。
 * （报数：共n个人 从1编号，设从第s个人报号，报到m出队，依次输出出队的人。）
 * *************************************************************/
 
test26.c
/******************************************************************
 * 出一个链表和一个数k，比如链表1→2→3→4→5→6，k=2，
 * 则翻转后2→1→4→3→6→5，若k=3,翻转后3→2→1→6→5→4，
 * 若k=4，翻转后4→3→2→1→6→5，用程序实现。
 * ****************************************************************/
 
test27.c
/*************************************************************
 * 将二维数组按照第k列排列，如果第k列相同，则按照第k+1列排列
 * *********************************************************/
 
test28.c
/**************************************************************
 * 求两个长长整形数据的和并输出
 * ************************************************************/
 
test29.c
/****************************************************************
 * 高精度的十进制加法
 * ************************************************************/
 
test2.c
/********************************************************************
 * 输入一棵二叉树的根结点，求树的深度
 * 从根结点到叶节点依次经过的结点（含根、叶结点）形成树的一条路径，
 * 最长路径的长度为树的深度
 * *****************************************************************/
 
test30.cpp
/*************************************************************
 * 输入两行字符串正整数，第一行是被减数，第二行是减数，
 * 输出第一行减去第二行的结果。
 * **********************************************************/
 
test31.c
/****************************************************************
 * 通过键盘输入一串小写字母(a~z)组成的字符串。请编写一个字符串过滤程序，
 * 若字符串中出现多个相同的字符，将非首次出现的字符过滤掉。
 * 比如字符串“abacacde”过滤结果为“abcde”。
 * *************************************************************/
 
test32.c
/*****************************************************************
 * 通过键盘输入一串小写字母(a~z)组成的字符串。请编写一个字符串压缩程序，将字符串中连续出席的重复字母进行压缩，并输出压缩后的字符串。
 * 压缩规则：
 * 1. 仅压缩连续重复出现的字符。比如字符串"abcbc"由于无连续重复字符，压缩后的字符串还是"abcbc".
 * 2. 压缩字段的格式为"字符重复的次数+字符"。例如：字符串"xxxyyyyyyz"压缩后就成为"3x6yz"
 * **************************************************************/
 
test33.cpp
/***************************************************************
 * 删除子串，只要是原串中有相同的子串就删掉，不管有多少个都删除，返回子串个数。
 * 输入字符串为：123abc12de234fg1hi34j123k，子串为：123
 * 则输出为：abc12de234fg1hi34jk   2
 * ************************************************************/
 
test34.cpp
/***************************************************************
 * 将输入的字符串（字符串仅包含小写字母‘a’到‘z’），按照如下规则，
 * 
 * 循环转换后输出：a->b,b->c,…,y->z,z->a；
 * 若输入的字符串连续出现两个字母相同时，后一个字母需要连续转换2次。
 * 
 * 例如：aa 转换为 bc，zz 转换为 ab；
 * 当连续相同字母超过两个时，第三个出现的字母按第一次出现算。
 * **************************************************************/
 
test35.cpp
/**************************************************************
 * 在给定字符串中找出单词（“单词”由大写字母和小写字母字符构成，
 * 其他非字母字符视为单词的间隔，如空格、问号、数字等等；
 * 另外单个字母不算单词）；找到单词后，按照长度进行降序排序，
 * （排序时如果长度相同，则按出现的顺序进行排列），
 * 然后输出到一个新的字符串中；如果某个单词重复出现多次，则只输出一次；
 * 如果整个输入的字符串中没有找到单词，请输出空串。
 * 输出的单词之间使用一个“空格”隔开，最后一个单词后不加空格.
 * **********************************************************/
 
test36.cpp
/***************************************************
 * 字符串单词首字母转换成大写
 * 举例：
 * 输入：this is a book
 * 返回：This Is A Book
 * ***************************************************/
 
test37.cpp
/******************************************************************
 * 通过键盘输入任意一个字符串序列，字符串可能包含多个子串，
 * 子串以空格分隔。请编写一个程序，自动分离出各个子串，
 * 并使用’,’将其分隔，并且在最后也补充一个’,’并将子串存储。  
 * 如果输入“abc def gh i        d”，结果将是abc,def,gh,i,d,。
 * **************************************************************/
 
test38.cpp
/********************************************************************
 * 输入一个字符串，删除其中所有的数字，
 * 所有大写字母改成小写，其他不变，并输出。
 * ****************************************************************/
 
test39.cpp
/********************************************************************
 * 编写一个字符串替换函数，如：“ABCDEFGHIJKLMNOPQRSTUVWXYZ”这个字符串，
 * 把其中的“RST”替换为“ggg”这个字符串，
 * 结果就变成了：ABCDEFGHIJKLMNOPQgggUVWXYZ
 * *****************************************************************/
 
test3.c
/******************************************************************
 * 输入一颗二叉树的根结点，判断该树是不是平衡二叉树
 * 如果二叉树中任意结点左右子树深度相差不超过1，则该树是平衡二叉树
 * ****************************************************************/
 
test40.c
/****************************************************************
 * 将两个字符串合并为一个字符串并且输出，用指针实现。
 * *************************************************************/
 
test41.c
/**********************************************************
 * 给定一个字符串,实现一个函数,按下述方式输出字符串： 
 * 如果此字符的下一个字符和此字符不一样，原样输出此字符， 
 * 否则先输出此字符，再输出此字符连续出现的次数（次数不大于9）。 
 * 例如,字符串ABBCCCDEDFFF，输出的结果为AB2C3DEDF3。 
 * 不用考虑溢出问题，不能使用任何I/O函数。
 * ******************************************************/
 
test42.cpp
/**********************************************************
 * 给定两个非常大的正整数A和B，位数在50到100之间。求C=A+B；
 * 如输入：111111111111111111111111111111111111111
 *		   222222222222222222222222222222222222222
 * 输出：333333333333333333333333333333333333333
 * ******************************************************/
 
test43.cpp
/******************************************************************
 * 实现输入一组大于等于0的整数，根据从小到大的顺序排序后输出，
 * 排序后有连续数时，只输出连续数中最小和最大的两个数。
 * 样例输入:	1,4,3,110,2,90,7
 * 样例输出:	1 4 7 90 110
 * ****************************************************************/
 
test44.c
/*********************************************************
 * 字符串匹配问题，给定两个字符串，求字符串2在字符串1中的最先匹配结果。
 * 字符串2中可以存在'*'符号，且该符号可以代表任意字符，
 * 即字符串2中存在通配符。
 * e.g. 输入：abcdefghabef, a*f    输出：abcdef''
 * *******************************************************/
 
test44.cpp
/*********************************************************
 * 字符串匹配问题，给定两个字符串，求字符串2在字符串1中的最先匹配结果。
 * 字符串2中可以存在'*'符号，且该符号可以代表任意字符，
 * 即字符串2中存在通配符。
 * e.g. 输入：abcdefghabef, a*f    输出：abcdef''
 * *******************************************************/
 
test45.c
/************************************************************
 * 输入m个字符串 和一个整数n, 把字符串M化成以N为单位的段，
 * 不足的位数用0补齐。
 * 如 n=8 m=9 ，
 * 123456789划分为：12345678   90000000
 * 123        化为 ：12300000
 * ********************************************************/
 
test46.c
/*********************************************************
 * 统计字符串中数字出现的次数，最大次数的统计出来
 * 举例：输入：323324423343输出：3,6
 * ********************************************************/
 
test47.cpp
/****************************************************************
 * 输入一段英文文本，用程序统计出现频率最高和最低的两个单词;
 * 英文文本中仅出现这四类字符：空格( )、英文逗号(,)、英文句号(.)、英文大小写字母（a-z、A-Z）
 * 单词之间的分隔符仅考虑这三种：空格( )、英文逗号(,)、英文句号(.);
 * 仅大小写不同的单词算同一个单词；
 * 如果两个单词出现次数相同，则在文本中首次出现的单词优先返回。
 * 返回的单词统一用小写字母返回
 * 例如：
 * 输入字符串“Hello world, i said hello world to the world”，返回“world”,“i”
 * *************************************************************/
 
test48.cpp
/********************************************************************
 * 将整数倒序输出，剔除重复数据
 * 输入一个整数，如12336544，或1750，然后从最后一位开始倒过来输出，
 * 最后如果是0，则不输出，输出的数字是不带重复数字的，
 * 所以上面的输出是456321和571。如果是负数，比如输入-175，输出-571。
 * *****************************************************************/
 
test49.cpp
/****************************************************************
 * 名字的漂亮度=26*字母个数最多的+25*字母个数其次的+24*字母个数再其次的
 * (忽略大小写)+....+1*出现次数最小的。
 * 输入：整数N，N个字符串
 * 输出：N个字符串漂亮度
 * 例如：输入1 a 输出 26
 * *************************************************************/
 
test4.c
/***************************************************************
 * 一个整形数组里除了一个数字外，其他数字都出现了两次。
 * 找出只出现一次的数字。要求时间复杂度O(n),空间复杂度O(1).
 * **************************************************************/
 
test50.cpp
/***********************************************
 * 输入一个10进制数字，请计算该数字对应二进制中0的个数，
 * 注意左数第一个1之前的所有0都不需要计算。不需要考虑负数的情况。
 * ********************************************/
 
test51.cpp
/*************************************************************
 * 判断是否为回文数组（无论从左到右还是从右到左读出来都一样的）。
 * *********************************************************/
 
test52.c
/**********************************************************************
 * 比较两个数组，要求从数组最后一个元素开始逐个元素向前比较，如果2个数组长度不等，则只比较较短长度数组个数元素。请编程实现上述比较，并返回比较中发现的不相等元素的个数
 * 比如：数组{1,3,5}和数组{77,21,1,3,5}按题述要求比较，不相等元素个数为0
 *       数组{1,3,5}和数组{77,21,1,3,5,7}按题述要求比较，不相等元素个数为3
 * ******************************************************************/
 
test52.cpp
/***********************************************************************
 * 比较两个数组，要求从数组最后一个元素开始逐个元素向前比较，如果2个数组长度不等，则只比较较短长度数组个数元素。请编程实现上述比较，并返回比较中发现的不相等元素的个数
 * 比如：数组{1,3,5}和数组{77,21,1,3,5}按题述要求比较，不相等元素个数为0
 *       数组{1,3,5}和数组{77,21,1,3,5,7}按题述要求比较，不相等元素个数为3
 * ********************************************************************/
 
test53.cpp
/******************************************************************
 * 如果数组长度n为奇数，则将数组中最大的元素放到 output[] 数组最中间的位置，如果数组长度n为偶数，则将数组中最大的元素放到 output[] 数组中间两个位置偏右的那个位置上，然后再按从大到小的顺序，依次在第一个位置的两边，按照一左一右的顺序，依次存放剩下的数。 
 * 例如：input[] = {3, 6, 1, 9, 7}      output[] = {3, 7, 9, 6, 1};            
 *       input[] = {3, 6, 1, 9, 7, 8}    output[] = {1, 6, 8, 9, 7, 3}
 * *****************************************************************/
 
test54.c
/*********************************************************************
 * 算分数，去掉一个最高分一个最低分，求平均分。
 * ******************************************************************/
 
test55.c
/**********************************************************************
 * 找出一个数组中满足2^N的元素。
 * 例如：输入1,2,3,5,7,8,16，则输出：符合条件的有：1 2 8 16 共4个
 * *******************************************************************/
 
test56.c
/**********************************************************************
 * 求一个二维数组每列的最小值和二维数组的最小值。
 * ******************************************************************/
 
test57.c
/*********************************************************************
 * 对一个数组，将数组中偶数从大到小排序，奇数从小到大排序,
 * 奇数和偶数交叉着放且输出数组第一位放奇数  若奇数和偶数不等长，
 * 则把剩下的直接放到数组中。
 * ******************************************************************/
 
test58.c
/**********************************************************
 * 求两个整型数组的异集，即A+B-(A与B的交集)。
 * 例如a[]={1,2,3,4,5}, b[]={2,3}，则a,b的异集为{1,4,5}。
 * *********************************************************/
 
test59.c
/****************************************************************
 * 给定一个n*m的矩阵，请编程实现以逆时针旋转方式打印出它的每个元素，
 * 例如输入矩阵
 * 1 8 7
 * 2 9 6
 * 3 4 5
 * 则输出为1 2 3 4 5 6 7 8 9。
 * ****************************************************************/
 
test5.c
/***************************************************************
 * 一个整形数组里除了两个数字外，其他数字都出现了两次。
 * 找出只出现一次的数字。要求时间复杂度O(n),空间复杂度O(1).
 * **************************************************************/
 
test60.c
/*******************************************************************
 * 通过键盘输入100以内正整数的加、减运算式，请编写一个程序输出运算结果字符串。
 * 输入字符串的格式为：“操作数1 运算符 操作数2”，“操作数”与“运算符”之间以一个空格隔开。
 * ***************************************************************/
 
test61.c
/*******************************************************************
 * 输入一个只包含个位数字的简单四则运算表达式字符串，计算该表达式的值
 * 注： 1、表达式只含 +, -, *, /, (, ), 四则运算符
 * 2、表达式数值只包含个位整数(0-9)，且不会出现0作为除数的情况
 * 3、要考虑加减乘除按通常四则运算规定的计算优先级
 * 4、除法用整数除法，即仅保留除法运算结果的整数部分。比如8/3=2。输入表达式保证无0作为除数情况发生
 * 5、输入字符串一定是符合题意合法的表达式，其中只包括数字字符和四则运算符字符，除此之外不含其它任何字符，不会出现计算溢出情况
 * ***************************************************************/
 
test62.c
/*******************************************************************
 * 最小公约数和最大公倍数
 * ****************************************************************/
 
test63.cpp
/*****************************************************************
 * 求一个正整数X的平方根Y，立方根Z。
 * 求平方根和立方根我们一般用牛顿迭代法，下面是对应的公式。
 * 平方根迭代公式a(n+1)=(a(n)+Y/a(n))/2，其中Y为待求平方根。
 * 立方根迭代公式a(n+1)={2a(n)+Z/{[a(n)]^2}}/3，其中Z为待求平方根。
 * ****************************************************************/
 
test64.cpp
/****************************************************************
 * 我们把只包含因子2，3，5的数称为丑数，把1当作第一个丑数，求从小到大的第n个丑数（还有质素）
 * 输入：n  输出：第n个丑数。
 * ************************************************************/
 
test65.cpp
/****************************************************************
 * 相关数：判断比整数N小的数里，有多少个与7相关的数（比如7、14、17、27）。
 * 只需要给出总的个数，不需要输出。
 * **************************************************************/
 
test66.cpp
/***********************************************************
 * 任意输入两个整数，求他们的最大公约数和最小公倍数。
 * *******************************************************/
 
test67.cpp
/********************************************************************
 * 自守数是指一个数的平方的尾数等于该数自身的自然数。
 * 例如：252= 625，762= 5776，93762= 87909376。请求出n以内的自守数的个数。
 * *****************************************************************/
 
test68.cpp
/*************************************************************
 * 任何一个自然数m的立方均可写成m个连续奇数之和。
 *	//　   1^3=1
	//　   2^3=3+5
	//　   3^3=7+9+11
	//　   4^3=13+15+17+19
	//编程实现：输入一自然数n，求组成n^3的n个连续奇数。
 * *******************************************************/
 
test69.cpp
/*********************************************************
 * 输入一串字符串，其中有普通的字符与括号组成（包括‘（’、‘）’、‘[’,']'）,\
 * 要求验证括号是否匹配，如果匹配则输出0、否则输出1.
 * ******************************************************/
 
test6.c
/************************************************************
 * 输入一个递增排序的数组和一个数字s，在数组中查找两个数，
 * 使得他们的和正好是s。如果有多对数组的和为s，输出任意一对。
 * *********************************************************/
 
test70.cpp
/********************************************************
 * 将 电话号码 one two...nine zero翻译成1  2...9 0
 * 中间会有double
 * 例如输入：OneTwoThree
 * 输出：123
 * 输入：OneTwoDoubleTwo
 * 输出：1222
 * 输入：1Two2 输出：ERROR
 * 输入：DoubleDoubleTwo 输出：ERROR
 * 有空格，非法字符，两个Double相连，Double位于最后一个单词，都错误，输出：ERROR
 * ******************************************************/
 
test71.cpp
/**************************************************************
 * A Program to transform words;
 * Takes two arguments: The first is name of the word transformation file
 *						The seconds is name of the input to transform
 * ************************************************************/
 
test72.cpp
/***********************************************************************
 * 编程的时候，if条件里面的“(”、“)”括号经常出现不匹配的情况导致编译不过，请编写程序检测输入一行if语句中的圆括号是否匹配正确。同时输出语句中出现的左括号和右括号数量，如if((a==1)&&(b==1))是正确的，而if((a==1))&&(b==1))是错误的。注意if语句的最外面至少有一对括号。
 * 输入：if((a==1)&&(b==1))
 * 输出：RIGTH 3 3
 * 输入：if((a==1))&&(b==1))
 * 输出：WRONG 3 4
 * *********************************************************************/
 
test73.cpp
/****************************************************************
 * 输入包括多个行数，首先给出整数N（1<N<10000），接着给出N行文字，
 * 每一行文字至少包括一个字符，至多100个字符。
 * 如果给定文字中“t”（或“T”）的出现次数比“s”（或“S”）多，则可能为英文，
 * 否则可能为德文。输出包括一行，
 * 如果输入文字可能为英文，则输出English，否则输出Deutsch。
 * ***********************************************************/
 
test74.cpp
/*******************************************************************
 * 自从有了智能手机，时刻都要关心手机的电量。你的任务很简单，用程序打印符号来表示当前手机的电量。
 * 用10行和10列来表示电池的电量，同时在外围加上边框，每一行表示10%的电量。
 * 假设还有60%的电量，则显示如下：
 * +----------+
 * |----------|
 * |----------|
 * |----------|
 * |----------|
 * |++++++++++|
 * |++++++++++|
 * |++++++++++|
 * |++++++++++|
 * |++++++++++|
 * |++++++++++|
 * +----------+
 * 运行时间限制: 无限制 
 * 内存限制: 无限制 
 * 输入: 多组测试数据，第一行为测试数据组数N（N<10），紧接着是N行，每行一个数，表示电量，这个数值可能是0，10，20 ，30，40，50，60，70，80，90，100
 * 输出: 每组数据输出一个电池的电量，每组数据之间用15个“=”隔开
 * ***************************************************************/
 
test75.cpp
/*********************************************************************
 * 在路由器中，一般来说转发模块采用最大前缀匹配原则进行目的端口查找，具体如下：
 * IP地址和子网地址匹配：
 * IP地址和子网地址所带掩码做AND运算后，得到的值与子网地址相同，则该IP地址与该子网匹配。
 * 
 * 比如：
 * IP地址：192.168.1.100
 * 子网：192.168.1.0/255.255.255.0，其中192.168.1.0是子网地址，255.255.255.0是子网掩码。
 * 192.168.1.100&255.255.255.0 = 192.168.1.0，则该IP和子网192.168.1.0匹配
 * IP地址：192.168.1.100
 * 子网：192.168.1.128/255.255.255.192
 * 192.168.1.100&255.255.255.192 = 192.168.1.64，则该IP和子网192.168.1.128不匹配
 * 最大前缀匹配：
 * 任何一个IPv4地址都可以看作一个32bit的二进制数，
 * 比如192.168.1.100可以表示为：11000000.10101000.00000001.01100100，
 * 192.168.1.0可以表示为11000000.10101000.00000001.00000000
 * 最大前缀匹配要求IP地址同子网地址匹配的基础上，二进制位从左到右完全匹配的位数尽量多（从左到右子网地址最长）。比如：
 * IP地址192.168.1.100，同时匹配子网192.168.1.0/255.255.255.0和子网192.168.1.64/255.255.255.192，
 * 但对于子网192.168.1.64/255.255.255.192，匹配位数达到26位，多于子网192.168.1.0/255.255.255.0的24位，因此192.168.1.100最大前缀匹配子网是192.168.1.64/255.255.255.192。
 * 示例 
 * 输入：
 * ip_addr = "192.168.1.100"
 * net_addr_array[] =
 * {
 * "192.168.1.128/255.255.255.192",
 * "192.168.1.0/255.255.255.0",
 * "192.168.1.64/255.255.255.192",
 * "0.0.0.0/0.0.0.0",
 * ""
 * }
 * 输出：n = 2
 * ****************************************************************/
 
test76.cpp
/***********************************************************************
 * 有一种技巧可以对数据进行加密，它使用一个单词作为它的密匙。下面是它的工作原理：首先，选择一个单词作为密匙，如TRAILBLAZERS。如果单词中包含有重复的字母，只保留第1个，其余几个丢弃。现在，修改过的那个单词死于字母表的下面，如下所示：
 * A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
 * T R A I L B Z E S C D F G H J K M N O P Q U V W X Y
 * 上面其他用字母表中剩余的字母填充完整。在对信息进行加密时，信息中的每个字母被固定于顶上那行，并用下面那行的对应字母一一取代原文的字母(字母字符的大小写状态应该保留)。因此，使用这个密匙，Attack AT DAWN(黎明时攻击)就会被加密为Tpptad TP ITVH。请实现下述接口，通过指定的密匙和明文得到密文。详细描述：接口说明：
 * 输入:先输入key和要加密的字符串  
 * 输出:返回加密后的字符串  
 * 样例输入: 
 * nihao
 * ni                    
 * 样例输出: le
 * ******************************************************************/
 
test77.cpp
/*************************************************************************
 * 我国大陆运营商的手机号码标准格式为：国家码+手机号码，例如：8613912345678。特点如下：
 * 1、  长度13位；
 * 2、  以86的国家码打头；
 * 3、  手机号码的每一位都是数字。
 *
 * 请实现手机号码合法性判断的函数要求：
 * 1）  如果手机号码合法，返回0；
 * 2）  如果手机号码长度不合法，返回1
 * 3）  如果手机号码中包含非数字的字符，返回2；
 * 4）  如果手机号码不是以86打头的，返回3；
 * 【注】除成功的情况外，以上其他合法性判断的优先级依次降低。也就是说，如果判断出长度不合法，直接返回1即可，不需要再做其他合法性判断。
 * 示例
 * 输入：  inMsisdn = “869123456789“
 * 输出：   1
 * 输入：  inMsisdn = “88139123456789“
 * 输出：   3
 * 输入：  inMsisdn = “86139123456789“
 * 输出：   0
 * ********************************************************************/
 
test78.cpp
/***************************************************************
 *	统计一个数二进制表达中0的个数（首位1之前0不计）。
 * *********************************************************/
 
test79.cpp
/***********************************************************
 * 输入一个数字，转换为时间，按DDD：HH：MM：SS的格式输出
 * 例如：输入100000 显示001:03:46:40
 * **********************************************************/
 
test7.c
/***************************************************
 * 输入一个正数s,打印出所有和为s的连续正数序列（至少包含两个数）
 * 如输入15， 1+2+3+4+5=4+5+6=7+8=15
 * 所以输出 1~5、4~6、7~8
 * ************************************************/
 
test80.cpp
/******************************************************************
 * 建立一个二叉树，求其高度，首先前、中、后序遍历，
 * 求叶子数，求数的深度并且判断是否为平衡二叉树。
 * *****************************************************************/
 
test81.cpp
/*******************************************************************
 * Given an unsorted array of integers, find the length of the longest consecutive elements sequence.
 * For example, Given [100, 4, 200, 1, 3, 2], The longest consecutive elements sequence is [1,
 * 2, 3, 4]. Return its length: 4.
 * Your algorithm should run in O(n) complexity.
 * ******************************************************************/
 
test82.cpp
/***********************************************************************
 * Given an array of integers, find two numbers such that they add up to a specific target number.
 * The function twoSum should return indices of the two numbers such that they add up to the target, where
 * index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not
 * zero-based.
 * You may assume that each input would have exactly one solution.
 * Input: numbers={2, 7, 11, 15}, target=9
 * Output: index1=1, index2=2
 * *******************************************************************/
 
test83.cpp
/*********************************************************************
 * Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique
 * triplets in the array which gives the sum of zero.
 * Note:
 * • Elements in a triplet (a, b, c) must be in non-descending order. (ie, a ≤ b ≤ c)
 * • The solution set must not contain duplicate triplets.
 * For example, given array S = {-1 0 1 2 -1 -4}.
 * A solution set is:
 * (-1, 0, 1)
 * (-1, -1, 2)
 * ******************************************************************/
 
test84.cpp
/******************************************************************
 * Given an array S of n integers, find three integers in S such that the sum is closest to a given number,
 * target. Return the sum of the three integers. You may assume that each input would have exactly one solution.
 * For example, given array S = {-1 2 1 -4}, and target = 1.
 * The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
 * *****************************************************************/
 
test85.cpp
/*********************************************************************
 * Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target?
 * Find all unique quadruplets in the array which gives the sum of target.
 * Note:
 * • Elements in a quadruplet (a, b, c, d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)
 * • The solution set must not contain duplicate quadruplets.
 * For example, given array S = {1 0 -1 0 -2 2}, and target = 0.
 * A solution set is:
 * (-1, 0, 0, 1)
 * (-2, -1, 1, 2)
 * (-2, 0, 0, 2)
 * *****************************************************************/
 
test86.cpp
/********************************************************************
 * Implement next permutation, which rearranges numbers into the lexicographically next greater permu-
 * tation of numbers.
 * If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascend-
 * ing order).
 * The replacement must be in-place, do not allocate extra memory.
 * Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the
 * right-hand column.
 * 1,2,3 → 1,3,2
 * 3,2,1 → 1,2,3
 * 1,1,5 → 1,5,1
 * ******************************************************************/
 
test87.cpp
/*********************************************************************
 * 把N 个鸡蛋放到 M 个篮子里，每个篮子不能为空，要满足：任意给出一个不超过 N 的数量，都能找到其中某几个篮子的鸡蛋和等于它。请写一个程序，输入 N,M ，然后输出所有鸡蛋的方法。
 * ******************************************************************/
 
test88.cpp
/**********************************************************************
 * You are given two linked lists representing two non-negative numbers. The digits are stored in reverse
 * order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
 * Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
 * Output: 7 -> 0 -> 8
 * *******************************************************************/
 
test89.cpp
/***********************************************************************
 * Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
 *
 * Note:
 * Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)
 * The solution set must not contain duplicate triplets.
 *     For example, given array S = {-1 0 1 2 -1 -4},
 *
 *     A solution set is:
 *         (-1, 0, 1)
 *         (-1, -1, 2)
 * *********************************************************************/
 
test8.c
/******************************************************************
 * 输入英文句子，翻转句子中单词的顺序，但单词中字符顺序不变。
 * 标点符号和普通字母一样处理。
 * 输入“I am a student.” 输出 “student. a am I”.
 * ****************************************************************/
 
test90.cpp
/************************************************************************
 *  Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
* The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.
 * **********************************************************************/
 
test91.cpp
/***********************************************************************
 * Implement strStr().
 *
 * Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
 *
 * Update (2014-11-02):
 * The signature of the function had been updated to return the index instead of the pointer. If you still see your function signature returns a char * or String, please click the reload button  to reset your code definition.
 * *******************************************************************/
 
test92.cpp
/***********************************************************************
 * Implement pow(x, n).
 * *********************************************************************/
 
test93.cpp
/***********************************************************************
 * Given a collection of intervals, merge all overlapping intervals.
 *
 * For example,
 * Given [1,3],[2,6],[8,10],[15,18],
 * return [1,6],[8,10],[15,18].
 * *********************************************************************/
 
test94.cpp
/***********************************************************************
 * LCS问题：动归+回溯
 * ********************************************************************/
 
test95.cpp
/******************************************************************
 * 根据上排给出十个数，在其下排填出对应的十个数
 * 要求下排每个数都是先前上排那十个数在下排出现的次数。
 * 上排的十个数如下：
 * 【0，1，2，3，4，5，6，7，8，9】
 * 举一个例子，
 * 数值: 【 0,1,2,3,4,5,6,7,8,9 】
 * 分配: 【 6,2,1,0,0,0,1,0,0,0 】
 * ***************************************************************/
 
test96.cpp
 * Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).
 *
 * You may assume that the intervals were initially sorted according to their start times.
 *
 * Example 1:
 * Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].
 *
 * Example 2:
 * Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].
 *
 * This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].
 * ********************************************************************/
 
test97.cpp
/******************************************************************
 * Validate if a given string is numeric.
 *
 * Some examples:
 * "0" => true
 * " 0.1 " => true
 * "abc" => false
 * "1 a" => false
 * "2e10" => true
 * Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.
 *
 * Update (2015-02-10):
 * The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button  to reset your code definition.""""""""""
 * ****************************************************************/
 
test98.cpp
/*********************************************************************
 * You are climbing a stair case. It takes n steps to reach to the top.
 *
 * Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
 * *******************************************************************/
 
test99.cpp
/********************************************************************
 * Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.
 *
 * Follow up:
 * Did you use extra space?
 * A straight forward solution using O(mn) space is probably a bad idea.
 * A simple improvement uses O(m + n) space, but still not the best solution.
 * Could you devise a constant space solution?
 * *******************************************************************/
 
test9.c
/****************************************************************
 * 字符串左旋操作是把字符串前面的若干字符转移到字符串的尾部。
 * 输入字符串“abcdefg”和2，返回左旋2位后得到的结果“cdefgab”
 * *************************************************************/
 
