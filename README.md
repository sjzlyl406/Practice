# Practice

Algorithm, Data Structure

Author :Leon(sjzlyl406)
Date :30 June 2015


(C) Copyright Leon(sjzlyl406) 2015. Permission to copy, use, modify, sell and distribute this software is granted provided this copyright notice appears in all copies. This software is provided "as is" without express or implied warranty, and with no claim as to its suitability for any purpose.


在terminal下运行
```
./index.sh
```
生成如下目录，这些目录里包含这个库中所有的题目，根据题目查找对应算法。


## 目录：
```

test100.cpp
/*******************************************************************
 * Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.
 *
 * Note:
 * You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.
 * ******************************************************************/
 
test101.cpp
/**********************************************************************
 * Given a binary tree, determine if it is a valid binary search tree (BST).
 *
 * Assume a BST is defined as follows:
 *
 * The left subtree of a node contains only nodes with keys less than the node's key.
 * The right subtree of a node contains only nodes with keys greater than the node's key.
 * Both the left and right subtrees must also be binary search trees.''
 * *****************************************************************/
 
test102.cpp
/**********************************************************************
 * Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
 *
 * For example,
 * "A man, a plan, a canal: Panama" is a palindrome.
 * "race a car" is not a palindrome.
 *
 * Note:
 * Have you consider that the string might be empty? This is a good question to ask during an interview.
 *
 * For the purpose of this problem, we define empty string as valid palindrome.""""
 * ********************************************************************/
 
test103.cpp
/**********************************************************************
 * 两个数相乘的高精度算法，
 * *******************************************************************/
 
test104.cpp
/*********************************************************************
 * Given two words (beginWord and endWord), and a dictionary, find the length of shortest transformation sequence from beginWord to endWord, such that:
 *
 * Only one letter can be changed at a time
 * Each intermediate word must exist in the dictionary
 * For example,
 *
 * Given:
 * start = "hit"
 * end = "cog"
 * dict = ["hot","dot","dog","lot","log"]
 * As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
 * return its length 5.
 *
 * Note:
 * Return 0 if there is no such transformation sequence.
 * All words have the same length.
 * All words contain only lowercase alphabetic characters.]
 * ******************************************************************/
 
test105.cpp
/************************************************************************
 * Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that:
 *
 * Only one letter can be changed at a time
 * Each intermediate word must exist in the dictionary
 * For example,
 *
 * Given:
 * start = "hit"
 * end = "cog"
 * dict = ["hot","dot","dog","lot","log"]
 * Return
 *   [
 *       ["hit","hot","dot","dog","cog"],
 *           ["hit","hot","lot","log","cog"]
 *             ]
 *             Note:
 *             All words have the same length.
 *             All words contain only lowercase alphabetic characters.
 *             ]
 *      ]
 *  ]
 * *******************************************************************/
 
test106.c
/**************************************************************
 * memcpy()
 * *************************************************************/
 
test107.cpp
/*******************************************************************
 * You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
 *
 * Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
 * Output: 7 -> 0 -> 8
 * *****************************************************************/
 
test108.cpp
/*********************************************************************
 * Given an integer, convert it to a roman numeral.
 *
 * Input is guaranteed to be within the range from 1 to 3999.
 * ******************************************************************/
 
test109.cpp
/*************************************************************************
 * Given a roman numeral, convert it to an integer.
 *
 * Input is guaranteed to be within the range from 1 to 3999.
 * **********************************************************************/
 
test10.c
/*******************************************************************
 * 把n个色子扔在地上，所有色子朝上一面的点数之和为s。
 * 输入n，打印出s的所有可能值出现的概率。
 * ****************************************************************/
 
test10.cpp
/*******************************************************************
 * 把n个色子扔在地上，所有色子朝上一面的点数之和为s。
 * 输入n，打印出s的所有可能值出现的概率。
 * ****************************************************************/
 
test110.cpp

/************************************************************************
 * Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
 *
 * For example, given n = 3, a solution set is:
 *
 * "((()))", "(()())", "(())()", "()(())", "()()()"
 * ********************************************************************/
 
test111.cpp
/***********************************************************************
 * Given a linked list, swap every two adjacent nodes and return its head.
 *
 * For example,
 * Given 1->2->3->4, you should return the list as 2->1->4->3.
 *
 * Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.
 * *******************************************************************/
 
test112.cpp
/*******************************************************************
 * Given an array and a value, remove all instances of that value in place and return the new length.
 *
 * The order of elements can be changed. It doesn't matter what you leave beyond the new length.'
 * *****************************************************************/
 
test113.cpp
/**********************************************************************
 * Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
 *
 * If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).
 *
 * The replacement must be in-place, do not allocate extra memory.
 *
 * Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.
 * 1,2,3 → 1,3,2
 * 3,2,1 → 1,2,3
 * 1,1,5 → 1,5,1
 * ********************************************************************/
 
test114.cpp
/*****************************************************************
 * Given an array of strings, return all groups of strings that are anagrams.
 *
 * Note: All inputs will be in lower-case.
 * *************************************************************/
 
test115.cpp
/**********************************************************************
 * Given two binary strings, return their sum (also a binary string).
 *
 * For example,
 * a = "11"
 * b = "1"
 * Return "100".
 * ******************************************************************/
 
test116.cpp
/******************************************************************
 * Implement int sqrt(int x).
 *
 * Compute and return the square root of x.
 * *****************************************************************/
 
test117.cpp
/************************************************************************
 * 给定一个排好升序的数组A[1]、A[2]、……、A[n]，其元素的值都两两不相等。
 * 请设计一高效的算法找出中间所有A[i] = i的下标。
 * *******************************************************************/
 
test118.cpp
/****************************************************************
 * Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.
 *
 * Ensure that numbers within the set are sorted in ascending order.
 *
 *
 * Example 1:
 *
 * Input: k = 3, n = 7
 *
 * Output:
 *
 * [[1,2,4]]
 *
 * Example 2:
 *
 * Input: k = 3, n = 9
 *
 * Output:
 *
 * [[1,2,6], [1,3,5], [2,3,4]]
 * Credits:
 * Special thanks to @mithmatt for adding this problem and creating all test cases.
 * ***************************************************************/
 
test119.cpp
/******************************************************************
 * Given a 2D board and a word, find if the word exists in the grid.
 *
 * The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
 *
 * For example,
 * Given board =
 *
 * [
 *   ["ABCE"],
 *   ["SFCS"],
 *   ["ADEE"]
 * ]
 *       word = "ABCCED", -> returns true,
 *       word = "SEE", -> returns true,
 *       word = "ABCB", -> returns false.
 * **************************************************************/
 
test11.cpp
/****************************************************************
 * 从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的
 * A为1，J为11，Q为12，K为13，而大小王看作任意数字。
 * *************************************************************/
 
test12.c
/**********************************************************************
 * 0，1，...，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里
 * 删除第m个数字。求出这个圆圈剩下最后一个数字。
 * ********************************************************************/
 
test12.cpp
/**********************************************************************
 * 0，1，...，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里
 * 删除第m个数字。求出这个圆圈剩下最后一个数字。
 * ********************************************************************/
 
test13.cpp
/*****************************************************************
 * 求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、
 * case等关键字及条件判断语句（A？B：C）。
 * **************************************************************/
 
test14.c
/*****************************************************************
 * 写一个函数， 求两个整数之和，要求在函数体内不得使用
 * +、-、*、/四则运算符号。
 * ***************************************************************/
 
test15.c
/*********************************************************
 * 编写StrToInt函数，实现字符串到正数数字的转换。
 * *******************************************************/
 
test16.c
/***************************************************
 * Remove Duplicates from Sorted Array return the new length
 * do not allocate new space
 * input A=[1,1,3] Output A=[1,3] and length = 2;
 * ************************************************/
 
test16.cpp
/***************************************************
 * Remove Duplicates from Sorted Array return the new length
 * do not allocate new space
 * input A=[1,1,3] Output A=[1,3] and length = 2;
 * ************************************************/
 
test17.c
/*********************************************************
 *	Remove Duplicates from sorted Array 2
 *	Input A={1,1,1,2,2,3} Output A={1,1,2,2,3} and length = 5
 * ******************************************************/
 
test18.c
/************************************************************
 * Search in Rotate Sorted Array
 * if found return its index, else return -1
 * i.e. input 4 5 6 7 0 1 2
 * *********************************************************/
 
test19.c
/***************************************************************
 * The Kth Number of Two Sorted Arrys
 * ***********************************************************/
 
test1.c
/******************************************************
 * 统计数字在排序数组中出现的次数。
 * 如输入排序数组{1,2,3,3,3,3,4,5} 和数字3
 * 输出 4
 * ****************************************************/
 
test1.cpp
/******************************************************
 * 统计数字在排序数组中出现的次数。
 * 如输入排序数组{1,2,3,3,3,3,4,5} 和数字3
 * 输出 4
 * ****************************************************/
 
test20.cpp
/**************************************************************
 * 输入10个数字，按各个位的和从小到大排序
 * 如输入 11 3 2 4 5 9 8 7 10 6
 * 输出 10 2 11 3 4 5 6 7 8 9
 * ***********************************************************/
 
test21.cpp
/***********************************************************************
 * 操作系统任务调度问题。操作系统任务分为系统任务和用户任务两种。其中，
 * 系统任务的优先级 < 50，用户任务的优先级 >= 50且 <= 255。优先级大于255的为非法任务，应予以剔除。
 * 现有一任务队列task[]，长度为n，task中的元素值表示任务的优先级，数值越小，优先级越高。 
 * 函数scheduler实现如下功能：
 * 将task[] 中的任务按照系统任务、用户任务依次存放到 system_task[] 数组和 user_task[] 数组中 
 * （数组中元素的值是任务在task[] 数组中的下标），并且优先级高的任务排在前面，数组元素为-1表示结束。
 * 例如：
 * task[] = {0, 30, 155, 1, 80, 300, 170, 40, 99}    
 * system_task[] = {0, 3, 1, 7, -1}    
 * user_task[]  =  {4, 8, 2, 6, -1}
 * 接口函数：
 * void scheduler(int task[], int n, int system_task[], int user_task[])
 * ********************************************************************/
 
test22.c
/*************************************************************
 * 输入一组身高在170到190之间（5个身高）比较身高，选出身高差最小的两个身高；若身高差相同，选平均身高高的那两个身高；从小到大输出；
 * 如：输入 170 181 173 186 190   输出 170 173
 * *********************************************************/
 
test23.c
/*************************************************************
 * 输入整型数组求数组的最小数和最大数之和，例
 * 如输入1,2,3,4则输出为5，当输入只有一个数的时候，则最小数和最大数都是该数，
 * 例如只输入1，则输出为2；数组的长度不超过50。
 * **********************************************************/
 
test24.c
/******************************************************************8
 * 输入一串字符，只包含“0-10”和“，”找出其中最小的数字和最大的数字
 * （可能不止一个），输出最后剩余数字个数。
 * ***************************************************************/
 
test25.c
/***************************************************************8
 * 一组人（7个），围成一圈，从某人开始数到第3个的人出列，
 * 再接着从下一个人开始数，依次输出出列的人。
 * （报数：共n个人 从1编号，设从第s个人报号，报到m出队，依次输出出队的人。）
 * *************************************************************/
 
test26.c
/******************************************************************
 * 出一个链表和一个数k，比如链表1→2→3→4→5→6，k=2，
 * 则翻转后2→1→4→3→6→5，若k=3,翻转后3→2→1→6→5→4，
 * 若k=4，翻转后4→3→2→1→6→5，用程序实现。
 * ****************************************************************/
 
test27.c
/*************************************************************
 * 将二维数组按照第k列排列，如果第k列相同，则按照第k+1列排列
 * *********************************************************/
 
test28.c
/**************************************************************
 * 求两个长长整形数据的和并输出
 * ************************************************************/
 
test29.c
/****************************************************************
 * 高精度的十进制加法
 * ************************************************************/
 
test2.c
/********************************************************************
 * 输入一棵二叉树的根结点，求树的深度
 * 从根结点到叶节点依次经过的结点（含根、叶结点）形成树的一条路径，
 * 最长路径的长度为树的深度
 * *****************************************************************/
 
test30.cpp
/*************************************************************
 * 输入两行字符串正整数，第一行是被减数，第二行是减数，
 * 输出第一行减去第二行的结果。
 * **********************************************************/
 
test31.c
/****************************************************************
 * 通过键盘输入一串小写字母(a~z)组成的字符串。请编写一个字符串过滤程序，
 * 若字符串中出现多个相同的字符，将非首次出现的字符过滤掉。
 * 比如字符串“abacacde”过滤结果为“abcde”。
 * *************************************************************/
 
test32.c
/*****************************************************************
 * 通过键盘输入一串小写字母(a~z)组成的字符串。请编写一个字符串压缩程序，将字符串中连续出席的重复字母进行压缩，并输出压缩后的字符串。
 * 压缩规则：
 * 1. 仅压缩连续重复出现的字符。比如字符串"abcbc"由于无连续重复字符，压缩后的字符串还是"abcbc".
 * 2. 压缩字段的格式为"字符重复的次数+字符"。例如：字符串"xxxyyyyyyz"压缩后就成为"3x6yz"
 * **************************************************************/
 
test33.cpp
/***************************************************************
 * 删除子串，只要是原串中有相同的子串就删掉，不管有多少个都删除，返回子串个数。
 * 输入字符串为：123abc12de234fg1hi34j123k，子串为：123
 * 则输出为：abc12de234fg1hi34jk   2
 * ************************************************************/
 
test34.cpp
/***************************************************************
 * 将输入的字符串（字符串仅包含小写字母‘a’到‘z’），按照如下规则，
 * 
 * 循环转换后输出：a->b,b->c,…,y->z,z->a；
 * 若输入的字符串连续出现两个字母相同时，后一个字母需要连续转换2次。
 * 
 * 例如：aa 转换为 bc，zz 转换为 ab；
 * 当连续相同字母超过两个时，第三个出现的字母按第一次出现算。
 * **************************************************************/
 
test35.cpp
/**************************************************************
 * 在给定字符串中找出单词（“单词”由大写字母和小写字母字符构成，
 * 其他非字母字符视为单词的间隔，如空格、问号、数字等等；
 * 另外单个字母不算单词）；找到单词后，按照长度进行降序排序，
 * （排序时如果长度相同，则按出现的顺序进行排列），
 * 然后输出到一个新的字符串中；如果某个单词重复出现多次，则只输出一次；
 * 如果整个输入的字符串中没有找到单词，请输出空串。
 * 输出的单词之间使用一个“空格”隔开，最后一个单词后不加空格.
 * **********************************************************/
 
test36.cpp
/***************************************************
 * 字符串单词首字母转换成大写
 * 举例：
 * 输入：this is a book
 * 返回：This Is A Book
 * ***************************************************/
 
test37.cpp
/******************************************************************
 * 通过键盘输入任意一个字符串序列，字符串可能包含多个子串，
 * 子串以空格分隔。请编写一个程序，自动分离出各个子串，
 * 并使用’,’将其分隔，并且在最后也补充一个’,’并将子串存储。  
 * 如果输入“abc def gh i        d”，结果将是abc,def,gh,i,d,。
 * **************************************************************/
 
test38.cpp
/********************************************************************
 * 输入一个字符串，删除其中所有的数字，
 * 所有大写字母改成小写，其他不变，并输出。
 * ****************************************************************/
 
test39.cpp
/********************************************************************
 * 编写一个字符串替换函数，如：“ABCDEFGHIJKLMNOPQRSTUVWXYZ”这个字符串，
 * 把其中的“RST”替换为“ggg”这个字符串，
 * 结果就变成了：ABCDEFGHIJKLMNOPQgggUVWXYZ
 * *****************************************************************/
 
test3.c
/******************************************************************
 * 输入一颗二叉树的根结点，判断该树是不是平衡二叉树
 * 如果二叉树中任意结点左右子树深度相差不超过1，则该树是平衡二叉树
 * ****************************************************************/
 
test40.c
/****************************************************************
 * 将两个字符串合并为一个字符串并且输出，用指针实现。
 * *************************************************************/
 
test41.c
/**********************************************************
 * 给定一个字符串,实现一个函数,按下述方式输出字符串： 
 * 如果此字符的下一个字符和此字符不一样，原样输出此字符， 
 * 否则先输出此字符，再输出此字符连续出现的次数（次数不大于9）。 
 * 例如,字符串ABBCCCDEDFFF，输出的结果为AB2C3DEDF3。 
 * 不用考虑溢出问题，不能使用任何I/O函数。
 * ******************************************************/
 
test42.cpp
/**********************************************************
 * 给定两个非常大的正整数A和B，位数在50到100之间。求C=A+B；
 * 如输入：111111111111111111111111111111111111111
 *		   222222222222222222222222222222222222222
 * 输出：333333333333333333333333333333333333333
 * ******************************************************/
 
test43.cpp
/******************************************************************
 * 实现输入一组大于等于0的整数，根据从小到大的顺序排序后输出，
 * 排序后有连续数时，只输出连续数中最小和最大的两个数。
 * 样例输入:	1,4,3,110,2,90,7
 * 样例输出:	1 4 7 90 110
 * ****************************************************************/
 
test44.c
/*********************************************************
 * 字符串匹配问题，给定两个字符串，求字符串2在字符串1中的最先匹配结果。
 * 字符串2中可以存在'*'符号，且该符号可以代表任意字符，
 * 即字符串2中存在通配符。
 * e.g. 输入：abcdefghabef, a*f    输出：abcdef''
 * *******************************************************/
 
test44.cpp
/*********************************************************
 * 字符串匹配问题，给定两个字符串，求字符串2在字符串1中的最先匹配结果。
 * 字符串2中可以存在'*'符号，且该符号可以代表任意字符，
 * 即字符串2中存在通配符。
 * e.g. 输入：abcdefghabef, a*f    输出：abcdef''
 * *******************************************************/
 
test45.c
/************************************************************
 * 输入m个字符串 和一个整数n, 把字符串M化成以N为单位的段，
 * 不足的位数用0补齐。
 * 如 n=8 m=9 ，
 * 123456789划分为：12345678   90000000
 * 123        化为 ：12300000
 * ********************************************************/
 
test46.c
/*********************************************************
 * 统计字符串中数字出现的次数，最大次数的统计出来
 * 举例：输入：323324423343输出：3,6
 * ********************************************************/
 
test47.cpp
/****************************************************************
 * 输入一段英文文本，用程序统计出现频率最高和最低的两个单词;
 * 英文文本中仅出现这四类字符：空格( )、英文逗号(,)、英文句号(.)、英文大小写字母（a-z、A-Z）
 * 单词之间的分隔符仅考虑这三种：空格( )、英文逗号(,)、英文句号(.);
 * 仅大小写不同的单词算同一个单词；
 * 如果两个单词出现次数相同，则在文本中首次出现的单词优先返回。
 * 返回的单词统一用小写字母返回
 * 例如：
 * 输入字符串“Hello world, i said hello world to the world”，返回“world”,“i”
 * *************************************************************/
 
test48.cpp
/********************************************************************
 * 将整数倒序输出，剔除重复数据
 * 输入一个整数，如12336544，或1750，然后从最后一位开始倒过来输出，
 * 最后如果是0，则不输出，输出的数字是不带重复数字的，
 * 所以上面的输出是456321和571。如果是负数，比如输入-175，输出-571。
 * *****************************************************************/
 
test49.cpp
/****************************************************************
 * 名字的漂亮度=26*字母个数最多的+25*字母个数其次的+24*字母个数再其次的
 * (忽略大小写)+....+1*出现次数最小的。
 * 输入：整数N，N个字符串
 * 输出：N个字符串漂亮度
 * 例如：输入1 a 输出 26
 * *************************************************************/
 
test4.c
/***************************************************************
 * 一个整形数组里除了一个数字外，其他数字都出现了两次。
 * 找出只出现一次的数字。要求时间复杂度O(n),空间复杂度O(1).
 * **************************************************************/
 
test50.cpp
/***********************************************
 * 输入一个10进制数字，请计算该数字对应二进制中0的个数，
 * 注意左数第一个1之前的所有0都不需要计算。不需要考虑负数的情况。
 * ********************************************/
 
test51.cpp
/*************************************************************
 * 判断是否为回文数组（无论从左到右还是从右到左读出来都一样的）。
 * *********************************************************/
 
test52.c
/**********************************************************************
 * 比较两个数组，要求从数组最后一个元素开始逐个元素向前比较，如果2个数组长度不等，则只比较较短长度数组个数元素。请编程实现上述比较，并返回比较中发现的不相等元素的个数
 * 比如：数组{1,3,5}和数组{77,21,1,3,5}按题述要求比较，不相等元素个数为0
 *       数组{1,3,5}和数组{77,21,1,3,5,7}按题述要求比较，不相等元素个数为3
 * ******************************************************************/
 
test52.cpp
/***********************************************************************
 * 比较两个数组，要求从数组最后一个元素开始逐个元素向前比较，如果2个数组长度不等，则只比较较短长度数组个数元素。请编程实现上述比较，并返回比较中发现的不相等元素的个数
 * 比如：数组{1,3,5}和数组{77,21,1,3,5}按题述要求比较，不相等元素个数为0
 *       数组{1,3,5}和数组{77,21,1,3,5,7}按题述要求比较，不相等元素个数为3
 * ********************************************************************/
 
test53.cpp
/******************************************************************
 * 如果数组长度n为奇数，则将数组中最大的元素放到 output[] 数组最中间的位置，如果数组长度n为偶数，则将数组中最大的元素放到 output[] 数组中间两个位置偏右的那个位置上，然后再按从大到小的顺序，依次在第一个位置的两边，按照一左一右的顺序，依次存放剩下的数。 
 * 例如：input[] = {3, 6, 1, 9, 7}      output[] = {3, 7, 9, 6, 1};            
 *       input[] = {3, 6, 1, 9, 7, 8}    output[] = {1, 6, 8, 9, 7, 3}
 * *****************************************************************/
 
test54.c
/*********************************************************************
 * 算分数，去掉一个最高分一个最低分，求平均分。
 * ******************************************************************/
 
test55.c
/**********************************************************************
 * 找出一个数组中满足2^N的元素。
 * 例如：输入1,2,3,5,7,8,16，则输出：符合条件的有：1 2 8 16 共4个
 * *******************************************************************/
 
test56.c
/**********************************************************************
 * 求一个二维数组每列的最小值和二维数组的最小值。
 * ******************************************************************/
 
test57.c
/*********************************************************************
 * 对一个数组，将数组中偶数从大到小排序，奇数从小到大排序,
 * 奇数和偶数交叉着放且输出数组第一位放奇数  若奇数和偶数不等长，
 * 则把剩下的直接放到数组中。
 * ******************************************************************/
 
test58.c
/**********************************************************
 * 求两个整型数组的异集，即A+B-(A与B的交集)。
 * 例如a[]={1,2,3,4,5}, b[]={2,3}，则a,b的异集为{1,4,5}。
 * *********************************************************/
 
test59.c
/****************************************************************
 * 给定一个n*m的矩阵，请编程实现以逆时针旋转方式打印出它的每个元素，
 * 例如输入矩阵
 * 1 8 7
 * 2 9 6
 * 3 4 5
 * 则输出为1 2 3 4 5 6 7 8 9。
 * ****************************************************************/
 
test5.c
/***************************************************************
 * 一个整形数组里除了两个数字外，其他数字都出现了两次。
 * 找出只出现一次的数字。要求时间复杂度O(n),空间复杂度O(1).
 * **************************************************************/
 
test60.c
/*******************************************************************
 * 通过键盘输入100以内正整数的加、减运算式，请编写一个程序输出运算结果字符串。
 * 输入字符串的格式为：“操作数1 运算符 操作数2”，“操作数”与“运算符”之间以一个空格隔开。
 * ***************************************************************/
 
test61.c
/*******************************************************************
 * 输入一个只包含个位数字的简单四则运算表达式字符串，计算该表达式的值
 * 注： 1、表达式只含 +, -, *, /, (, ), 四则运算符
 * 2、表达式数值只包含个位整数(0-9)，且不会出现0作为除数的情况
 * 3、要考虑加减乘除按通常四则运算规定的计算优先级
 * 4、除法用整数除法，即仅保留除法运算结果的整数部分。比如8/3=2。输入表达式保证无0作为除数情况发生
 * 5、输入字符串一定是符合题意合法的表达式，其中只包括数字字符和四则运算符字符，除此之外不含其它任何字符，不会出现计算溢出情况
 * ***************************************************************/
 
test62.c
/*******************************************************************
 * 最小公约数和最大公倍数
 * ****************************************************************/
 
test63.cpp
/*****************************************************************
 * 求一个正整数X的平方根Y，立方根Z。
 * 求平方根和立方根我们一般用牛顿迭代法，下面是对应的公式。
 * 平方根迭代公式a(n+1)=(a(n)+Y/a(n))/2，其中Y为待求平方根。
 * 立方根迭代公式a(n+1)={2a(n)+Z/{[a(n)]^2}}/3，其中Z为待求平方根。
 * ****************************************************************/
 
test64.cpp
/****************************************************************
 * 我们把只包含因子2，3，5的数称为丑数，把1当作第一个丑数，求从小到大的第n个丑数（还有质素）
 * 输入：n  输出：第n个丑数。
 * ************************************************************/
 
test65.cpp
/****************************************************************
 * 相关数：判断比整数N小的数里，有多少个与7相关的数（比如7、14、17、27）。
 * 只需要给出总的个数，不需要输出。
 * **************************************************************/
 
test66.cpp
/***********************************************************
 * 任意输入两个整数，求他们的最大公约数和最小公倍数。
 * *******************************************************/
 
test67.cpp
/********************************************************************
 * 自守数是指一个数的平方的尾数等于该数自身的自然数。
 * 例如：252= 625，762= 5776，93762= 87909376。请求出n以内的自守数的个数。
 * *****************************************************************/
 
test68.cpp
/*************************************************************
 * 任何一个自然数m的立方均可写成m个连续奇数之和。
 *	//　   1^3=1
	//　   2^3=3+5
	//　   3^3=7+9+11
	//　   4^3=13+15+17+19
	//编程实现：输入一自然数n，求组成n^3的n个连续奇数。
 * *******************************************************/
 
test69.cpp
/*********************************************************
 * 输入一串字符串，其中有普通的字符与括号组成（包括‘（’、‘）’、‘[’,']'）,\
 * 要求验证括号是否匹配，如果匹配则输出0、否则输出1.
 * ******************************************************/
 
test6.c
/************************************************************
 * 输入一个递增排序的数组和一个数字s，在数组中查找两个数，
 * 使得他们的和正好是s。如果有多对数组的和为s，输出任意一对。
 * *********************************************************/
 
test70.cpp
/********************************************************
 * 将 电话号码 one two...nine zero翻译成1  2...9 0
 * 中间会有double
 * 例如输入：OneTwoThree
 * 输出：123
 * 输入：OneTwoDoubleTwo
 * 输出：1222
 * 输入：1Two2 输出：ERROR
 * 输入：DoubleDoubleTwo 输出：ERROR
 * 有空格，非法字符，两个Double相连，Double位于最后一个单词，都错误，输出：ERROR
 * ******************************************************/
 
test71.cpp
/**************************************************************
 * A Program to transform words;
 * Takes two arguments: The first is name of the word transformation file
 *						The seconds is name of the input to transform
 * ************************************************************/
 
test72.cpp
/***********************************************************************
 * 编程的时候，if条件里面的“(”、“)”括号经常出现不匹配的情况导致编译不过，请编写程序检测输入一行if语句中的圆括号是否匹配正确。同时输出语句中出现的左括号和右括号数量，如if((a==1)&&(b==1))是正确的，而if((a==1))&&(b==1))是错误的。注意if语句的最外面至少有一对括号。
 * 输入：if((a==1)&&(b==1))
 * 输出：RIGTH 3 3
 * 输入：if((a==1))&&(b==1))
 * 输出：WRONG 3 4
 * *********************************************************************/
 
test73.cpp
/****************************************************************
 * 输入包括多个行数，首先给出整数N（1<N<10000），接着给出N行文字，
 * 每一行文字至少包括一个字符，至多100个字符。
 * 如果给定文字中“t”（或“T”）的出现次数比“s”（或“S”）多，则可能为英文，
 * 否则可能为德文。输出包括一行，
 * 如果输入文字可能为英文，则输出English，否则输出Deutsch。
 * ***********************************************************/
 
test74.cpp
/*******************************************************************
 * 自从有了智能手机，时刻都要关心手机的电量。你的任务很简单，用程序打印符号来表示当前手机的电量。
 * 用10行和10列来表示电池的电量，同时在外围加上边框，每一行表示10%的电量。
 * 假设还有60%的电量，则显示如下：
 * +----------+
 * |----------|
 * |----------|
 * |----------|
 * |----------|
 * |++++++++++|
 * |++++++++++|
 * |++++++++++|
 * |++++++++++|
 * |++++++++++|
 * |++++++++++|
 * +----------+
 * 运行时间限制: 无限制 
 * 内存限制: 无限制 
 * 输入: 多组测试数据，第一行为测试数据组数N（N<10），紧接着是N行，每行一个数，表示电量，这个数值可能是0，10，20 ，30，40，50，60，70，80，90，100
 * 输出: 每组数据输出一个电池的电量，每组数据之间用15个“=”隔开
 * ***************************************************************/
 
test75.cpp
/*********************************************************************
 * 在路由器中，一般来说转发模块采用最大前缀匹配原则进行目的端口查找，具体如下：
 * IP地址和子网地址匹配：
 * IP地址和子网地址所带掩码做AND运算后，得到的值与子网地址相同，则该IP地址与该子网匹配。
 * 
 * 比如：
 * IP地址：192.168.1.100
 * 子网：192.168.1.0/255.255.255.0，其中192.168.1.0是子网地址，255.255.255.0是子网掩码。
 * 192.168.1.100&255.255.255.0 = 192.168.1.0，则该IP和子网192.168.1.0匹配
 * IP地址：192.168.1.100
 * 子网：192.168.1.128/255.255.255.192
 * 192.168.1.100&255.255.255.192 = 192.168.1.64，则该IP和子网192.168.1.128不匹配
 * 最大前缀匹配：
 * 任何一个IPv4地址都可以看作一个32bit的二进制数，
 * 比如192.168.1.100可以表示为：11000000.10101000.00000001.01100100，
 * 192.168.1.0可以表示为11000000.10101000.00000001.00000000
 * 最大前缀匹配要求IP地址同子网地址匹配的基础上，二进制位从左到右完全匹配的位数尽量多（从左到右子网地址最长）。比如：
 * IP地址192.168.1.100，同时匹配子网192.168.1.0/255.255.255.0和子网192.168.1.64/255.255.255.192，
 * 但对于子网192.168.1.64/255.255.255.192，匹配位数达到26位，多于子网192.168.1.0/255.255.255.0的24位，因此192.168.1.100最大前缀匹配子网是192.168.1.64/255.255.255.192。
 * 示例 
 * 输入：
 * ip_addr = "192.168.1.100"
 * net_addr_array[] =
 * {
 * "192.168.1.128/255.255.255.192",
 * "192.168.1.0/255.255.255.0",
 * "192.168.1.64/255.255.255.192",
 * "0.0.0.0/0.0.0.0",
 * ""
 * }
 * 输出：n = 2
 * ****************************************************************/
 
test76.cpp
/***********************************************************************
 * 有一种技巧可以对数据进行加密，它使用一个单词作为它的密匙。下面是它的工作原理：首先，选择一个单词作为密匙，如TRAILBLAZERS。如果单词中包含有重复的字母，只保留第1个，其余几个丢弃。现在，修改过的那个单词死于字母表的下面，如下所示：
 * A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
 * T R A I L B Z E S C D F G H J K M N O P Q U V W X Y
 * 上面其他用字母表中剩余的字母填充完整。在对信息进行加密时，信息中的每个字母被固定于顶上那行，并用下面那行的对应字母一一取代原文的字母(字母字符的大小写状态应该保留)。因此，使用这个密匙，Attack AT DAWN(黎明时攻击)就会被加密为Tpptad TP ITVH。请实现下述接口，通过指定的密匙和明文得到密文。详细描述：接口说明：
 * 输入:先输入key和要加密的字符串  
 * 输出:返回加密后的字符串  
 * 样例输入: 
 * nihao
 * ni                    
 * 样例输出: le
 * ******************************************************************/
 
test77.cpp
/*************************************************************************
 * 我国大陆运营商的手机号码标准格式为：国家码+手机号码，例如：8613912345678。特点如下：
 * 1、  长度13位；
 * 2、  以86的国家码打头；
 * 3、  手机号码的每一位都是数字。
 *
 * 请实现手机号码合法性判断的函数要求：
 * 1）  如果手机号码合法，返回0；
 * 2）  如果手机号码长度不合法，返回1
 * 3）  如果手机号码中包含非数字的字符，返回2；
 * 4）  如果手机号码不是以86打头的，返回3；
 * 【注】除成功的情况外，以上其他合法性判断的优先级依次降低。也就是说，如果判断出长度不合法，直接返回1即可，不需要再做其他合法性判断。
 * 示例
 * 输入：  inMsisdn = “869123456789“
 * 输出：   1
 * 输入：  inMsisdn = “88139123456789“
 * 输出：   3
 * 输入：  inMsisdn = “86139123456789“
 * 输出：   0
 * ********************************************************************/
 
test78.cpp
/***************************************************************
 *	统计一个数二进制表达中0的个数（首位1之前0不计）。
 * *********************************************************/
 
test79.cpp
/***********************************************************
 * 输入一个数字，转换为时间，按DDD：HH：MM：SS的格式输出
 * 例如：输入100000 显示001:03:46:40
 * **********************************************************/
 
test7.c
/***************************************************
 * 输入一个正数s,打印出所有和为s的连续正数序列（至少包含两个数）
 * 如输入15， 1+2+3+4+5=4+5+6=7+8=15
 * 所以输出 1~5、4~6、7~8
 * ************************************************/
 
test80.cpp
/******************************************************************
 * 建立一个二叉树，求其高度，首先前、中、后序遍历，
 * 求叶子数，求数的深度并且判断是否为平衡二叉树。
 * *****************************************************************/
 
test81.cpp
/*******************************************************************
 * Given an unsorted array of integers, find the length of the longest consecutive elements sequence.
 * For example, Given [100, 4, 200, 1, 3, 2], The longest consecutive elements sequence is [1,
 * 2, 3, 4]. Return its length: 4.
 * Your algorithm should run in O(n) complexity.
 * ******************************************************************/
 
test82.cpp
/***********************************************************************
 * Given an array of integers, find two numbers such that they add up to a specific target number.
 * The function twoSum should return indices of the two numbers such that they add up to the target, where
 * index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not
 * zero-based.
 * You may assume that each input would have exactly one solution.
 * Input: numbers={2, 7, 11, 15}, target=9
 * Output: index1=1, index2=2
 * *******************************************************************/
 
test83.cpp
/*********************************************************************
 * Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique
 * triplets in the array which gives the sum of zero.
 * Note:
 * • Elements in a triplet (a, b, c) must be in non-descending order. (ie, a ≤ b ≤ c)
 * • The solution set must not contain duplicate triplets.
 * For example, given array S = {-1 0 1 2 -1 -4}.
 * A solution set is:
 * (-1, 0, 1)
 * (-1, -1, 2)
 * ******************************************************************/
 
test84.cpp
/******************************************************************
 * Given an array S of n integers, find three integers in S such that the sum is closest to a given number,
 * target. Return the sum of the three integers. You may assume that each input would have exactly one solution.
 * For example, given array S = {-1 2 1 -4}, and target = 1.
 * The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
 * *****************************************************************/
 
test85.cpp
/*********************************************************************
 * Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target?
 * Find all unique quadruplets in the array which gives the sum of target.
 * Note:
 * • Elements in a quadruplet (a, b, c, d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)
 * • The solution set must not contain duplicate quadruplets.
 * For example, given array S = {1 0 -1 0 -2 2}, and target = 0.
 * A solution set is:
 * (-1, 0, 0, 1)
 * (-2, -1, 1, 2)
 * (-2, 0, 0, 2)
 * *****************************************************************/
 
test86.cpp
/********************************************************************
 * Implement next permutation, which rearranges numbers into the lexicographically next greater permu-
 * tation of numbers.
 * If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascend-
 * ing order).
 * The replacement must be in-place, do not allocate extra memory.
 * Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the
 * right-hand column.
 * 1,2,3 → 1,3,2
 * 3,2,1 → 1,2,3
 * 1,1,5 → 1,5,1
 * ******************************************************************/
 
test87.cpp
/*********************************************************************
 * 把N 个鸡蛋放到 M 个篮子里，每个篮子不能为空，要满足：任意给出一个不超过 N 的数量，都能找到其中某几个篮子的鸡蛋和等于它。请写一个程序，输入 N,M ，然后输出所有鸡蛋的方法。
 * ******************************************************************/
 
test88.cpp
/**********************************************************************
 * You are given two linked lists representing two non-negative numbers. The digits are stored in reverse
 * order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
 * Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
 * Output: 7 -> 0 -> 8
 * *******************************************************************/
 
test89.cpp
/***********************************************************************
 * Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
 *
 * Note:
 * Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)
 * The solution set must not contain duplicate triplets.
 *     For example, given array S = {-1 0 1 2 -1 -4},
 *
 *     A solution set is:
 *         (-1, 0, 1)
 *         (-1, -1, 2)
 * *********************************************************************/
 
test8.c
/******************************************************************
 * 输入英文句子，翻转句子中单词的顺序，但单词中字符顺序不变。
 * 标点符号和普通字母一样处理。
 * 输入“I am a student.” 输出 “student. a am I”.
 * ****************************************************************/
 
test90.cpp
/************************************************************************
 *  Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
* The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.
 * **********************************************************************/
 
test91.cpp
/***********************************************************************
 * Implement strStr().
 *
 * Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
 *
 * Update (2014-11-02):
 * The signature of the function had been updated to return the index instead of the pointer. If you still see your function signature returns a char * or String, please click the reload button  to reset your code definition.
 * *******************************************************************/
 
test92.cpp
/***********************************************************************
 * Implement pow(x, n).
 * *********************************************************************/
 
test93.cpp
/***********************************************************************
 * Given a collection of intervals, merge all overlapping intervals.
 *
 * For example,
 * Given [1,3],[2,6],[8,10],[15,18],
 * return [1,6],[8,10],[15,18].
 * *********************************************************************/
 
test94.cpp
/***********************************************************************
 * LCS问题：动归+回溯
 * ********************************************************************/
 
test95.cpp
/******************************************************************
 * 根据上排给出十个数，在其下排填出对应的十个数
 * 要求下排每个数都是先前上排那十个数在下排出现的次数。
 * 上排的十个数如下：
 * 【0，1，2，3，4，5，6，7，8，9】
 * 举一个例子，
 * 数值: 【 0,1,2,3,4,5,6,7,8,9 】
 * 分配: 【 6,2,1,0,0,0,1,0,0,0 】
 * ***************************************************************/
 
test96.cpp
 * Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).
 *
 * You may assume that the intervals were initially sorted according to their start times.
 *
 * Example 1:
 * Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].
 *
 * Example 2:
 * Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].
 *
 * This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].
 * ********************************************************************/
 
test97.cpp
/******************************************************************
 * Validate if a given string is numeric.
 *
 * Some examples:
 * "0" => true
 * " 0.1 " => true
 * "abc" => false
 * "1 a" => false
 * "2e10" => true
 * Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.
 *
 * Update (2015-02-10):
 * The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button  to reset your code definition.""""""""""
 * ****************************************************************/
 
test98.cpp
/*********************************************************************
 * You are climbing a stair case. It takes n steps to reach to the top.
 *
 * Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
 * *******************************************************************/
 
test99.cpp
/********************************************************************
 * Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.
 *
 * Follow up:
 * Did you use extra space?
 * A straight forward solution using O(mn) space is probably a bad idea.
 * A simple improvement uses O(m + n) space, but still not the best solution.
 * Could you devise a constant space solution?
 * *******************************************************************/
 
test9.c
/****************************************************************
 * 字符串左旋操作是把字符串前面的若干字符转移到字符串的尾部。
 * 输入字符串“abcdefg”和2，返回左旋2位后得到的结果“cdefgab”
 * *************************************************************/

```
